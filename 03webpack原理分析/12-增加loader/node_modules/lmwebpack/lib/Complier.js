const fs = require("fs");
const ejs = require("ejs");
const path = require("path");
const parser = require("@babel/parser");
const traverse = require("@babel/traverse").default;
const generate = require("@babel/generator").default;
const t = require("@babel/types");



class Complier {
    constructor(config) {
        // 保存配置文件
        this.config = config;
        // 保存模块依赖关系
        // { 打包文件地址：打包文件内容的形式存储 }
        this.modules = {};
    };
    run() {
        this.buildModule(this.config.entry);
        this.emitFile();
    };
    // 将依赖关系保存到this.modules之中
    buildModule(modulePath) {
        let code = this.getSource(modulePath);
        // 修改主模块中的代码，替换require，修改路径
        let { resultCode, dependencies } = this.parseModule(code);
        // 以key:value形式保存主模块代码
        this.modules[modulePath] = resultCode;
        dependencies.forEach((depPath) => {
            this.buildModule(depPath);
        })
    };
    parseModule(code) {
        // 修改require
        let ast = parser.parse(code);
        let rootPath = path.dirname(this.config.entry);
        // 定义一个数组保存引入模块的路径
        let dependencies = [];
        traverse(ast, {
            CallExpression(nodePath) {
                let node = nodePath.node;
                if (node.callee.name === "require") {
                    node.callee.name = "__webpack_require__";
                    // 修改主页面引入模块的路径
                    let modulePath = node.arguments[0].value;
                    modulePath = ".\\" + path.join(rootPath, modulePath);
                    modulePath = modulePath.replace(/\\/g, "/");
                    dependencies.push(modulePath);
                    node.arguments = [t.StringLiteral(modulePath)];
                }
            }
        })
        // 将修改之后的抽象语法树转换为代码
        let resultCode = generate(ast).code;
        // 返回结果
        return { resultCode, dependencies };
    }
    // 读取文件内容
    getSource(modulePath) {
        // 根据传递的路径读取文件内容
        let content = fs.readFileSync(modulePath, "utf8");
        // 拿到配置文件中的规则
        let rules = this.config.module.rules;
        rules.forEach(function (rule) {
            let { test, use } = rule;
            // 判断当前传递的路径是否需要用loader来处理
            if (test.test(modulePath)) {
                for (let i = use.length - 1; i >= 0; i--) {
                    let loader = require(use[i]['loader']);
                    // 将我们读取到的内容传递给我们的loader处理
                    content = loader(content);
                }
            }
        })
        // 返回读取文件内容
        return content;
    }
    emitFile() {
        // 读取EJS模板
        let templatePath = path.resolve(__dirname, "main.ejs");
        let template = fs.readFileSync(templatePath, "utf8");
        // 将模板中的参数替换并返回给我们
        let resultCode = ejs.render(template, {
            entryId: this.config.entry,
            modules: this.modules
        })
        // 通过出口文件配置，创建对应的文件以及文件夹
        let outputDir = this.config.output.path;
        // 判断打包文件是否存在
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir);
        }
        let outputPath = path.resolve(outputDir, this.config.output.filename);
        fs.writeFileSync(outputPath, resultCode);
    }
}

module.exports = Complier;